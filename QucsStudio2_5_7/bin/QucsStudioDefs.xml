<!--
  Copyright (C) 2006 Laurent Lemaitre <r29173@users.sourceforge.net>
  Copyright (C) 2006 Helene Parruitte <parruit@enseirb.fr>
  Copyright (C) 2006 Bertrand Ardouin <ardouin@xmodtech.com>
  Copyright (C) 2006-2009 Stefan Jahn <stefan@lkcc.org>
  Copyright (C) 2011-2016 Michael Margraf <michael.margraf@alumni.tu-berlin.de>

  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.
-->

<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- controlling variable -->
<admst:variable name="SkipFVariable" string="n"/>
<admst:variable name="temperature_value" string="300"/>

<!-- temporary variable -->
<admst:variable name="pprobe"/>
<admst:variable name="e"/>
<admst:variable name="ep"/>

<!--
* Returns the type of a variable. The returned type
* is either int, double, or char *.
-->
<admst:template match="vtype">
  <admst:choose>
    <admst:when test="[type='integer']">int</admst:when>
    <admst:when test="[type='real']">double</admst:when>
    <admst:when test="[type='string']">char*</admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- comparison, bit and logical operators -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" string="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" string="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" string="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" string="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" string="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" string="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" string="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" string="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" string="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" string="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" string="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" string="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" string="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" string="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" string="&lt;&lt;"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:return name="bname" string="%"/>
    </admst:when>
     <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:fatal format="operator unknown: %s.\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//function: get function name -->
<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="fname" string="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" string="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" string="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" string="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" string="log"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" string="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" string="limexp"/></admst:when>
    <admst:otherwise><admst:return name="fname" string="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="e">
  <admst:apply-templates select="." match="%(datatypename)">$e</admst:apply-templates>
</admst:template>

<admst:template match="ddx">
  <admst:apply-templates select="." match="%(datatypename)"/>
</admst:template>

<admst:template match="dxname">
  <admst:return name="dxname" string="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
</admst:template>

<!-- array -->
<admst:template match="array">
  <admst:variable name="e" string="%(variable)[%(index)]"/>
  <admst:variable name="ep" string="0.0"/>
</admst:template>

<!-- variables -->
<admst:template match="variable">
  <admst:variable name="e" path="name"/>
  <admst:variable name="ep" string="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:variable name="ep" select="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>
</admst:template>

<!-- expression//probe -->
<admst:template match="probe">
  <admst:choose>
    <admst:when test="[nature/access='I']">
      <admst:variable name="e" select="sys->getV(vnode_%(branch/pnode/name)_%(branch/nnode/name), GND)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="sys->getV(%(branch/pnode/name), %(branch/nnode/name))"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="[.=$pprobe]">
      <admst:variable name="ep" select="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" string="0.0"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//node -->
<admst:template match="node">
  <admst:fatal format="module node not expected here ... %(name)\n"/>
</admst:template>

<!-- expression//string -->
<admst:template match="string">
  <admst:variable name="e" select="&quot;%(value)&quot;"/>
  <admst:variable name="ep" string="0.0"/>
</admst:template>

<!-- expression//number -->
<admst:template match="number">
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:variable name="e" path="value"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:variable name="e" select="(%(value)*1e18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:variable name="e" select="(%(value)*1e15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:variable name="e" select="(%(value)*1e12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:variable name="e" select="(%(value)*1e9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:variable name="e" select="(%(value)*1e6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:variable name="e" select="(%(value)*1e3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:variable name="e" select="(%(value)*1e2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:variable name="e" select="(%(value)*10.0)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:variable name="e" select="(%(value)*0.1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:variable name="e" select="(%(value)*1e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:variable name="e" select="(%(value)*1e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:variable name="e" select="(%(value)*1e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:variable name="e" select="(%(value)*1e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:variable name="e" select="(%(value)*1e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:variable name="e" select="(%(value)*1e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:variable name="e" select="(%(value)*1e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:variable name="e" select="(%(value)*1e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" string="0.0"/>
</admst:template>

<!-- unary operations -->
<admst:template match="mapply_unary">
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(+$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(-$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(!$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(~$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(name): function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="ep" string="0.0"/>
    </admst:when>
    <admst:when test="[$ep='0.0']">
      <admst:variable name="ep" string="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="ep" select="(+$ep)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="ep" select="(-$ep)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="ep" select="(!$ep)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="ep" select="(~$ep)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- binary operations -->
<admst:template match="mapply_binary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" string="$e"/>
  <admst:variable name="xp" string="$ep"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" string="$e"/>
  <admst:variable name="yp" string="$ep"/>
  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(+$y)"/>
          <admst:variable name="xp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="e" path="$x"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(-$y)"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="$ep"/>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:variable name="e" string="$x"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[(name='equ')and(arg2/datatypename='string')]">
          <admst:variable name="e" select="(strcmp($x, $y) == 0)"/>
        </admst:when>
        <admst:when test="[(name='notequ')and(arg2/datatypename='string')]">
          <admst:variable name="e" select="strcmp($x, $y)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x%(bname(.)/[name='bname']/value)$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" string="$yp"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" string="$xp"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="($xp+$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="(-$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" string="$xp"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="($xp-$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[$x='0.0' and $y='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0' and $yp='1.0']">
          <admst:variable name="ep" select="($x)"/>
        </admst:when>
        <admst:when test="[$xp='1.0' and $yp='0.0']">
          <admst:variable name="ep" select="($y)"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="($x*$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" select="($xp*$y)"/>
        </admst:when>
        <admst:when test="[$xp='1.0' and $yp='1.0']">
          <admst:variable name="ep" select="($x+$y)"/>
        </admst:when>
        <admst:when test="[$xp='1.0']">
          <admst:variable name="ep" select="($y+$yp*$x)"/>
        </admst:when>
        <admst:when test="[$yp='1.0']">
          <admst:variable name="ep" select="($xp*$y+$x)"/>
        </admst:when>
        <admst:when test="[$x='1.0']">
          <admst:variable name="ep" string="$yp"/>
        </admst:when>
        <admst:when test="[$y='1.0']">
          <admst:variable name="ep" string="$xp"/>
        </admst:when>
        <admst:when test="[$x=$y]">
          <admst:variable name="ep" select="(2.0*$xp*$y)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="($xp*$y+$x*$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[$x='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$x='1.0']">
          <admst:choose>
            <admst:when test="[$yp='1.0']">
              <admst:variable name="ep" select="(-1/$y/$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" select="(-$yp/$y/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:choose>
            <admst:when test="[$yp='1.0']">
              <admst:variable name="ep" select="(-$x/$y/$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" select="(-$x*$yp/$y/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[$xp='1.0']">
          <admst:choose>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" select="(1/$y)"/>
            </admst:when>
            <admst:when test="[$yp='1.0']">
              <admst:variable name="ep" select="(($y-$x)/$y/$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" select="(($y-$x*$yp)/$y/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[$y='1.0']">
              <admst:variable name="ep" string="$xp"/>
            </admst:when>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" select="($xp/$y)"/>
            </admst:when>
            <admst:when test="[$yp='1.0']">
              <admst:variable name="ep" select="(($xp*$y-$x)/$y/$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" select="(($xp-$x/$y*$yp)/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" string="0.0"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ternary operations -->
<admst:template match="mapply_ternary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" string="$e"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" string="$e"/>
  <admst:variable name="yp" string="$ep"/>
  <admst:apply-templates select="arg3" match="ddx"/>
  <admst:variable name="z" string="$e"/>
  <admst:variable name="zp" string="$ep"/>
  <admst:variable name="e" select="($x?$y:$z)"/>
  <admst:variable name="ep" select="($x?$yp:$zp)"/>
</admst:template>

<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="function">
  <admst:choose>
    <admst:when test="[name='absdelay']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" string="$e"/>
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="e" select="$x"/>
    </admst:when>
    <admst:when test="[name='\$given' or name='\$param_given']">
      <admst:variable name="arg1" path="arguments[1]"/>
      <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
      <admst:choose>
        <admst:when test="$arg1/[parametertype='model']">
          <admst:variable name="e" select="(%($arg1/name) == 1)"/>
        </admst:when>
        <admst:when test="$arg1/[parametertype='instance']">
          <admst:variable name="e" select="(%($arg1/name) == 1)"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="%(name): should not be reached\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="$temperature_value"/>
    </admst:when>
    <admst:when test="[name='\$mfactor']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="MFACTOR"/>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="e" string="(KB_DIV_Q*$temperature_value)"/>   
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" string="$e"/>
          <admst:variable name="xp" string="$ep"/>
          <admst:variable name="e" select="vt($x)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$abstime']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="_time_"/>
    </admst:when>
    <admst:when test="[name='ddx']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
      <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="$ep"/>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="floor($e)"/>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="ceil($e)"/>
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='acosh' or name='exp' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='asinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:variable name="index" path="index(subexpression/expression/function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two argument exactly\n"/>
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" string="$e"/>
      <admst:variable name="yp" string="$ep"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="dargs" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$dargs!='']">
          <admst:variable name="dargs" select="$dargs,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="dargs" select="$dargs$ep"/>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[class='builtin']">
          <admst:variable name="e" select="$(fname)($args)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="$(module)_$(fname)($args)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" string="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given' or name='\$param_given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="ep" select="$xp*m10_vt($x)"/>
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx' or name='floor' or name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="ep" string="$xp"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='acosh' or name='exp' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='asinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:variable name="index" path="index(subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$xp*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="(d11_$(fname)$index*$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp+d11_$(fname)$index*$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[class='builtin']">
          <admst:variable name="ep" select="d_$(fname)($args,$dargs)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$(module)_d_$(fname)($args,$dargs)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//block -->
<admst:template match="block">
  <admst:text format="  {\n"/>
  <admst:apply-templates select="item" match="%(datatypename)"/>
  <admst:text format="  }\n"/>
</admst:template>

<!-- analog//blockvariable -->
<admst:template match="blockvariable">
  <admst:text select="variable" format="  %(vtype(.)) %(name);\n"/>
  <admst:if test="variable[insource='yes']/probe">
    <admst:for-each select="variable">
      <admst:variable name="myvariable" path="."/>
      <admst:text select="probe" format="  double %($myvariable/name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

<!-- analog//function: ddx handling -->
<admst:template match="function:precomputation">
  <admst:variable name="index" path="index(../function,.)"/>
  <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
  <admst:text format="    double d00_$(fname)$index = $(fname)("/>
  <admst:variable name="ret" select=""/>
  <admst:for-each select="arguments">
    <admst:if test="[not($ret='')]">
      <admst:text format=","/>
    </admst:if>
    <admst:variable name="ret" select="%(e(.))"/>
  </admst:for-each>
  <admst:text format=");\n"/>
</admst:template>

<admst:template match="function:derivate:precomputation">
  <admst:apply-templates select="function" match="function:precomputation"/>
  <admst:if test="[hasVoltageDependentFunction='yes']">
    <admst:for-each select="function">
      <admst:variable name="index" path="index(../function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:choose>
        <admst:when test="[name='exp']">
            <admst:if test="arguments/math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="  #define d10_exp$index d00_exp$index\n"/>
            </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:for-each select="arguments">
            <admst:variable name="position" path="position(.)-1"/>
            <admst:if test="math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="    double m1%(position(.)-1)_$(fname)(d1%(position(.)-1)_$(fname)$index,d00_$(fname)$index"/>
              <admst:text select="../arguments" format=",%(e(.))"/>
              <admst:text format=")\n"/>
            </admst:if>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
  </admst:if>
</admst:template>

<!-- analog//assignment (example: br=5*Vk;) -->
<admst:template match="assignment">
  <admst:variable name="assignment" path="."/>
  <admst:variable name="rhs" path="rhs"/>
  <admst:variable name="lhs" path="lhs"/>
  <admst:choose>
    <admst:when test="rhs/function">
      <admst:variable name="leadingspaces" string="    "/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="leadingspaces" string="  "/>
    </admst:otherwise>
  </admst:choose>
  <admst:text test="rhs/function" format="  {\n"/>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:choose>
    <admst:when test="rhs/tree/adms[datatypename='function']/..[name='ddx']">
      <admst:variable name="ddxprobe" path="rhs/tree/arguments[2]"/>
      <admst:variable name="allep"/>
      <admst:for-each select="$lhs/probe">
        <admst:variable name="pprobe" path="."/>
        <admst:choose>
          <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
            <admst:variable name="allep" select="$allep+($ep)"/>
          </admst:when>
          <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
            <admst:variable name="allep" select="$allep-($ep)"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:apply-templates select="lhs" match="variable"/>
      <admst:text format="$leadingspaces$e=$allep;\n"/>
    </admst:when>
    <admst:when test="lhs[datatypename='array']">
      <admst:apply-templates select="lhs" match="array"/>
      <admst:text format="$leadingspaces$e=%(e(rhs/tree));\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:if test="lhs[insource='yes']">
        <admst:for-each select="lhs/probe">
          <admst:variable name="pprobe" path="."/>
          <admst:variable name="isinside" string="0"/>
          <admst:if test="$rhs/probe[.=$pprobe]">
            <admst:variable name="isinside" string="1"/>
          </admst:if>
          <admst:variable name="ep" string="0.0"/>
          <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(datatypename)"/>
          <admst:text format="$leadingspaces%(dxname($lhs)/[name='dxname']/value)=$ep;\n"/>
        </admst:for-each>
      </admst:if>
      <admst:apply-templates select="lhs" match="variable"/>
      <admst:text format="$leadingspaces$e=%(e(rhs/tree));\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text test="rhs/function" format="  }\n"/>
</admst:template>

<!-- analog//contribution[noise] -->
<admst:template match="contribution:noise">
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:text format="  gVar->noise%(./lhs/nature/access)_%(./lhs/branch/pnode/name)_%(./lhs/branch/nnode/name) += "/>
  <admst:if test="[whitenoise='yes']">
    <admst:apply-templates select="rhs/tree/arguments[1]" match="%(datatypename)"/>
    <admst:text format="fabs($e)"/>
  </admst:if>
  <admst:if test="[flickernoise='yes']">
    <admst:apply-templates select="rhs/tree/arguments[1]" match="%(datatypename)"/>
    <admst:text format="fabs($e) * pow(_freq_, -"/>
    <admst:apply-templates select="rhs/tree/arguments[2]" match="%(datatypename)"/>
    <admst:text format="$e)"/>
  </admst:if>
  <admst:text format=";\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
</admst:template>

<!-- analog//contribution -->
<admst:template match="contribution">
  <admst:choose>
    <admst:when test="[whitenoise='no' and flickernoise='no']">
      <admst:apply-templates select="." match="contribution:nonoise" required="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:noise" required="yes"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//contribution[nonoise] -->
<admst:template match="contribution:nonoise">
  <admst:text format="\n"/>
  <admst:text test="rhs/function" format="{\n"/>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:variable name="sourcepnodename" path="lhs/branch/pnode/name"/>
  <admst:variable name="sourcennodename" path="lhs/branch/nnode/name"/>
  <admst:choose>
    <admst:when test="[lhs/nature/access='G']">
      <admst:if test="[dynamic='yes']">
        <admst:fatal format="'G(b) <+ ddt(...)' is not possible.\n"/>
      </admst:if>
      <admst:if test="[not(nilled(rhs/probe))]">
        <admst:fatal format="'G(b) <+ conductance' is only possible for constant arguments.\n"/>
      </admst:if>
      <admst:text format="  sys->setG($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
    </admst:when>
    <admst:when test="[lhs/nature/access='R']">
      <admst:if test="[dynamic='yes']">
        <admst:fatal format="'R(b) <+ ddt(...)' is not possible.\n"/>
      </admst:if>
      <admst:if test="[not(nilled(rhs/probe))]">
        <admst:fatal format="'R(b) <+ resistance' is only possible for constant arguments.\n"/>
      </admst:if>
      <admst:text format="  sys->setR($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
    </admst:when>
    <admst:when test="[lhs/nature/access='C']">
      <admst:if test="[dynamic='yes']">
        <admst:fatal format="'C(b) <+ ddt(...)' is not possible.\n"/>
      </admst:if>
      <admst:if test="[not(nilled(rhs/probe))]">
        <admst:fatal format="'C(b) <+ capacitance' is only possible for constant arguments.\n"/>
      </admst:if>
      <admst:text format="  sys->setC($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
    </admst:when>
    <admst:when test="[rhs/tree/datatypename='number']">
      <admst:choose>
        <admst:when test="[lhs/nature/access='I']">
          <admst:text format="  sys->setI($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
        </admst:when>
        <admst:when test="[rhs/tree/value='0' or rhs/tree/value='0.0']">
          <admst:text format="  sys->setR($sourcepnodename,$sourcennodename, 0.0);\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="  sys->setA($sourcepnodename,vnode_$(sourcepnodename)_$sourcennodename, 1.0);\n"/>
          <admst:text format="  sys->setA($sourcennodename,vnode_$(sourcepnodename)_$sourcennodename,-1.0);\n"/>
          <admst:text format="  sys->setA(vnode_$(sourcepnodename)_$sourcennodename,$sourcepnodename,-1.0);\n"/>
          <admst:text format="  sys->setA(vnode_$(sourcepnodename)_$sourcennodename,$sourcennodename, 1.0);\n"/>
          <admst:text format="  sys->setI($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:if test="[lhs/nature/access='V']">
        <admst:text format="  sys->setA($sourcepnodename,vnode_$(sourcepnodename)_$sourcennodename, 1.0);\n"/>
        <admst:text format="  sys->setA($sourcennodename,vnode_$(sourcepnodename)_$sourcennodename,-1.0);\n"/>
        <admst:text format="  sys->setA(vnode_$(sourcepnodename)_$sourcennodename,$sourcepnodename,-1.0);\n"/>
        <admst:text format="  sys->setA(vnode_$(sourcepnodename)_$sourcennodename,$sourcennodename, 1.0);\n"/>
        <admst:variable name="sourcepnodename" select="vnode_%(lhs/branch/pnode/name)_%(lhs/branch/nnode/name)"/>
        <admst:variable name="sourcennodename" select="GND"/>
      </admst:if>
      <admst:text format="  sys->setIQ($sourcepnodename,$sourcennodename,"/>
      <admst:choose>
        <admst:when test="[dynamic='yes']">
          <admst:text format="0,%(e(rhs/tree)));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="%(e(rhs/tree)),0);\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="rhs/probe">
        <admst:variable name="probepnodename" path="branch/pnode/name"/>
        <admst:variable name="probennodename" path="branch/nnode/name"/>
        <admst:variable name="pprobe" path="."/>
        <admst:if test="[nature/access='I']">
          <admst:variable name="probepnodename" select="vnode_%(branch/pnode/name)_%(branch/nnode/name)"/>
          <admst:variable name="probennodename" select="GND"/>
        </admst:if>
        <admst:apply-templates select="../tree" match="%(datatypename)"/>
        <admst:text format="  sys->setGC($sourcepnodename,$sourcennodename,$probepnodename,$probennodename,"/>
        <admst:choose>
          <admst:when test="../..[dynamic='yes']">
            <admst:text format="0,$ep);\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="$ep,0);\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:otherwise>
  </admst:choose>
  <admst:text test="rhs/function" format="}\n"/>
</admst:template>

<!-- analog//conditional -->
<admst:template match="conditional">
  <admst:text test="if/function" format="{\n"/>
  <admst:apply-templates select="if/function" match="function:precomputation"/>
  <admst:text format="  if(%(e(if/tree)))\n"/>
  <admst:text select="then/adms[datatypename!='block']" format="  {\n"/>
  <admst:apply-templates select="then" match="%(datatypename)"/>
  <admst:text select="then/adms[datatypename!='block']" format="  }\n"/>
  <admst:if test="else">
    <admst:text format="  else\n"/>
    <admst:text test="else/adms[datatypename!='block']" format="  {\n"/>
    <admst:apply-templates select="else" match="%(datatypename)"/>
    <admst:text test="else/adms[datatypename!='block']" format="  }\n"/>
  </admst:if>
  <admst:text test="if/function" format="}\n"/>
</admst:template>

<!-- analog//nilled -->
<admst:template match="nilled">
</admst:template>

<!-- analog//whileloop -->
<admst:template match="whileloop">
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:text format="  while(%(e(while/tree)))\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="  {\n"/>
  <admst:apply-templates select="whileblock" match="%(datatypename)"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="  }\n"/>
</admst:template>

<!-- analog//forloop -->
<admst:template match="forloop">
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:text format="  for(%(e(initial/lhs))=%(e(initial/rhs/tree));"/>
  <admst:text format="%(e(condition/tree));"/>
  <admst:text format="%(e(update/lhs))=%(e(update/rhs/tree)))\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
  <admst:text select="forblock/adms[datatypename!='block']" format="  {\n"/>
  <admst:apply-templates select="forblock" match="%(datatypename)"/>
  <admst:text select="forblock/adms[datatypename!='block']" format="  }\n"/>
</admst:template>

<!-- analog//case -->
<admst:template match="case">
  <admst:variable name="casecondition" path="case/tree"/>
  <admst:variable name="havedefault" string="no"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:variable name="havedefault" string="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='no']">
      <admst:text format="  if("/>
      <admst:join select="condition" separator="||">
        <admst:apply-templates select="." match="%(datatypename)"/>
        <admst:text format="($casecondition)==($e)"/>
      </admst:join>
      <admst:text format=")\n"/>
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
      <admst:text format="  else\n"/>
    </admst:if>
  </admst:for-each>
  <admst:text select="[$havedefault='no']" format="  { /* no default */ }\n"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:variable name="limiter" string=""/>
      <admst:text format="  printf("/>
      <admst:for-each select="function/arguments">
        <admst:text format="$limiter%(e(tree))"/>
        <admst:variable name="limiter" string=", "/>
      </admst:for-each>
      <admst:text format=");\n"/>
    </admst:when>
    <admst:when test="function[name='\$warning']">
      <admst:variable name="limiter" string=""/>
      <admst:text format="  printWarning("/>
      <admst:for-each select="function/arguments">
        <admst:text format="$limiter%(e(tree))"/>
        <admst:variable name="limiter" string=", "/>
      </admst:for-each>
      <admst:text format=");\n"/>
    </admst:when>
    <admst:when test="function[name='\$error']">
      <admst:variable name="limiter" string=""/>
      <admst:text format="  printError("/>
      <admst:for-each select="function/arguments">
        <admst:text format="$limiter%(e(tree))"/>
        <admst:variable name="limiter" string=", "/>
      </admst:for-each>
      <admst:text format=");\n"/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:text format="  return;\n"/>
    </admst:when>
    <admst:when test="function[name='\$stop']">
      <admst:text format="  exit(0);\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="'%(function/name)' not supported\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- variable declaration -->
<admst:template match="variable:declaration">
  <admst:if test="block/adms[datatypename='module']">
    <admst:text test="[scope='local']" format="  %(vtype(.)) %(name);\n"/>
    <admst:if test="[insource='yes']/probe">
      <admst:text select="probe" format="  double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- variable declaration without derivatives -->
<admst:template match="variable:declaration:only">
  <admst:if test="block/adms[datatypename='module']">
    <admst:text test="[scope='local']" format="  %(vtype(.)) %(name);\n"/>
  </admst:if>
</admst:template>

<!-- block local variable declaration
  collects all assignments and puts it into /module/analog/code/module/evaluation/variable -->
<admst:template match="block:local:declaration">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:if test="lhs[datatypename!='array']">
        <admst:if test="lhs[sizetype='scalar']">
          <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
        </admst:if>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration"/>
      <admst:apply-templates select="else" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="block:local:declaration"/>
      <admst:apply-templates select="forblock" match="block:local:declaration"/>
      <admst:apply-templates select="update" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="adms[datatypename='case']">
      <admst:for-each select="caseitem">
        <admst:apply-templates select="code" match="block:local:declaration"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(datatypename)': should not be reached\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//[noise]  collect data for global noise variables -->
<admst:template match="nilled:specialContrib">
</admst:template>

<admst:template match="callfunction:specialContrib">
</admst:template>

<admst:template match="assignment:specialContrib">
</admst:template>

<admst:template match="blockvariable:specialContrib">
</admst:template>

<admst:template match="whileloop:specialContrib">
  <admst:apply-templates select="whileblock" match="%(datatypename):specialContrib"/>
</admst:template>

<admst:template match="forloop:specialContrib">
  <admst:apply-templates select="forblock" match="%(datatypename):specialContrib"/>
</admst:template>

<admst:template match="case:specialContrib">
  <admst:for-each select="caseitem">
    <admst:apply-templates select="code" match="%(datatypename):specialContrib" required="yes"/>
  </admst:for-each>
</admst:template>

<admst:template match="block:specialContrib">
  <admst:apply-templates select="item" match="%(datatypename):specialContrib"/>
</admst:template>

<admst:template match="conditional:specialContrib">
  <admst:apply-templates select="then" match="%(datatypename):specialContrib"/>
  <admst:if test="else">
    <admst:apply-templates select="else" match="%(datatypename):specialContrib"/>
  </admst:if>
</admst:template>

<admst:template match="contribution:specialContrib">
  <admst:if test="[lhs/nature/access='V']">
    <admst:if test="[rhs/tree/datatypename!='number' or (rhs/tree/value!='0' and rhs/tree/value!='0.0')]">
      <admst:push into="$vnodeList/item" select="lhs/branch" onduplicate="ignore"/>
    </admst:if>
  </admst:if>
  <admst:if test="[whitenoise='yes' or flickernoise='yes']">
    <admst:push into="$noiseList/item" select="lhs" onduplicate="ignore"/>
  </admst:if>
</admst:template>


<!--
* This template returns the description of an instance or 
* a model parameter. It works for both formats of :
*   `ATTR(info="description"  ...)
* or
*   `ATTR(desc="description"  ...)
-->
<admst:template match="variable:desc">
  <admst:choose>
    <admst:when test="attribute[name='desc' or name='info']">
      <admst:return name="variable:desc" string="&quot;%(attribute[name='desc' or name='info']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:desc" string="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the unit of an instance or 
* a model parameter as given in the VA file.
-->
<admst:template match="variable:unit">
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:return name="variable:unit" string="&quot;%(attribute[name='unit']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:unit" string="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>


<!-- **************************************************************************
     *****                                                                *****
     *****           templates for VerilogA analog functions              *****
     *****                                                                *****
     ************************************************************************** -->


<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="function:getname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="function:getname" value="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="function:getname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="function:getname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="function:getname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="function:getname" value="log"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$vt']"><admst:return name="function:getname" value="vt"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:return name="function:getname" value="$temperature_value"/></admst:when>
    <admst:otherwise><admst:value-of select="name"/><admst:return name="function:getname" value="%s"/></admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="af:print:expression">
  <admst:choose>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="expression" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:return name="x" value="$expression"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="$(dx_%s)"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='probe']">
      <admst:fatal format="probe not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='variable']">

      <admst:value-of select="name"/>
      <admst:variable name="variable" select="%s"/>
      <admst:return name="x" value="$variable"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="ddx" select="%s"/>
        <admst:choose>
          <admst:when test="[$variable='$ddx']">
            <admst:return name="dx.$ddx" value="1.0"/>
          </admst:when>
          <admst:when test="../..[input='yes']">
            <admst:return name="dx.$ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="dx.$ddx" value="$(variable)_$ddx"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>

    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:if test="[name='plus']">
        <admst:variable name="op" select="+"/>
      </admst:if>
      <admst:if test="[name='minus']">
        <admst:variable name="op" select="-"/>
      </admst:if>
      <admst:if test="[name='not']">
        <admst:variable name="op" select="!"/>
      </admst:if>
      <admst:if test="[name='bw_not']">
        <admst:variable name="op" select="~"/>
      </admst:if>
      <admst:apply-templates select="arg1" match="af:print:expression"><admst:value-of select="returned('x')/value"/><admst:variable name="arg1" select="%s"/></admst:apply-templates>
      <admst:return name="x" value="($op$arg1)"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dy_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(+$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(-$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' or $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:return name="dx.$df" value="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:return name="dx.$df" value="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:return name="dx.$df" value="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$(df))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:return name="dx.$df" value="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='bw_equr']">
              <admst:return name="x" value="($x^~$y)"/>
            </admst:when>
            <admst:when test="[name='bw_equl']">
              <admst:return name="x" value="($x~^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_xor']">
              <admst:return name="x" value="($x^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_or']">
              <admst:return name="x" value="($x|$y)"/>
            </admst:when>
            <admst:when test="[name='bw_and']">
              <admst:return name="x" value="($x&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='or']">
              <admst:return name="x" value="($x||$y)"/>
            </admst:when>
            <admst:when test="[name='and']">
              <admst:return name="x" value="($x&amp;&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='equ']">
              <admst:return name="x" value="($x==$y)"/>
            </admst:when>
            <admst:when test="[name='multmod']">
              <admst:return name="x" value="((int)$x%%(int)$y)"/>
            </admst:when>
            <admst:when test="[name='notequ']">
              <admst:return name="x" value="($x!=$y)"/>
            </admst:when>
            <admst:when test="[name='lt']">
              <admst:return name="x" value="($x&lt;$y)"/>
            </admst:when>
            <admst:when test="[name='lt_equ']">
              <admst:return name="x" value="($x&lt;=$y)"/>
            </admst:when>
            <admst:when test="[name='gt']">
              <admst:return name="x" value="($x&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='gt_equ']">
              <admst:return name="x" value="($x&gt;=$y)"/>
            </admst:when>
            <admst:when test="[name='shiftr']">
              <admst:return name="x" value="($x&gt;&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='shiftl']">
              <admst:return name="x" value="($x&lt;&lt;$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-of select="name"/>
              <admst:error format="%s: function not handled\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:return name="dx.%s" value="0.0"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="z" select="%s"/>
      </admst:apply-templates>
      <admst:if test="[name='conditional']">
        <admst:return name="x" value="($x?$y:$z)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:return name="dx.%s" value="($x?$dy_%s:$dz_%s)"/>
        </admst:for-each>
      </admst:if>
    </admst:when>

    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="." match="function:getname">
        <admst:value-of select="returned('function:getname')/value"/>
        <admst:variable name="function" select="%s"/>
      </admst:apply-templates>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[not($args='')]">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args%s"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:value-of select="returned('dx.%s')/value"/>
            <admst:value-of select="name"/>
            <admst:variable name="arg$(index)_%s" select="%s"/>
          </admst:for-each>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[ name='cos' or name='sin' or name='tan' or name='cosh' or name='sinh' or name='tanh' or name='acos' or name='asin'
                            or name='atan' or name='acosh' or name='asinh' or name='atanh' or name='ln' or name='log' or name='exp' or name='sqrt' or name='abs' or name='limexp'
                            or name='div' or name='pow' or name='hypot' or name='min' or name='max' or name='\$vt' ]">
          <admst:return name="x" value="$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="ret" select=""/>
            <admst:for-each select="../../arguments">
              <admst:if test="[not($ret='')]">
                <admst:variable name="ret" select="$ret+"/>
              </admst:if>
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="ret" select="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="$ret"/>
          </admst:for-each>
        </admst:when>

        <admst:otherwise>
          <admst:return name="x" value="$(module)_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="darg" select=""/>
            <admst:for-each select="../../arguments">
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="darg" select="$darg,($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="$(module)_d_$function($args$darg)"/>
          </admst:for-each>
        </admst:otherwise>

      </admst:choose>
    </admst:when>

    <admst:when test="adms[datatypename='string']">
      <admst:value-of select="value"/>
      <admst:return name="x" value="&quot;%s&quot;"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="%s"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="scalingunit"/>
          <admst:fatal format="scaling unit not supported: %s\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside expression\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="af:print:derivate">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:value-of select="lhs/name"/>
      <admst:variable name="lhs" select="%s"/>
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:variable name="rhs" select=""/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="rhs" select="$rhs  $(lhs)_%s=%s;\n"/>
        </admst:for-each>
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="rhs" select="$rhs  $lhs=%s;\n"/>
      </admst:apply-templates>
      <admst:return name="x" value="{\n$rhs  }\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select="  {\n"/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block  %s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$block  }"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="af:print">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:value-of select="../lhs/name"/>
        <admst:return name="x" value="%s=%s;\n"/>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select="  {\n"/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block  %s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$block  }"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="analogfunctionC">
<admst:for-each select="/module/analogfunction">
  <admst:value-of select="."/>
  <admst:variable name="globalanalogfunction" select="%p"/>
  <admst:value-of select="name"/>
  <admst:variable name="function" select="%s"/>
  <admst:text format="\n// analog function: $(function)\n"/>
  <admst:apply-templates select="." match="vtype"/>
  <admst:text format=" $(module)_$function ("/>
  <admst:join select="variable[input='yes']" separator=", ">
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="vtype"/>
	<admst:text format=" %s"/>
  </admst:join>
  <admst:text format=")\n{\n"/>
  <admst:text format="  double $function=0.0;\n"/>
  <admst:for-each select="variable[input='no' and output='no']">
    <admst:text format="  "/>
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="vtype"/>
    <admst:text format=" %s"/>
    <admst:if test="[type='integer']">=0</admst:if>
    <admst:if test="[type='real']">=0.0</admst:if>
    <admst:text format=";\n"/>
  </admst:for-each>
  <admst:apply-templates select="tree" match="af:print">
    <admst:value-of select="returned('x')/value"/>
    <admst:text format="%s"/>
  </admst:apply-templates>
  <admst:text format="\n  return $function;\n}\n\n"/>
  <admst:text format="double $(module)_d_$(function) ("/>
  <admst:join select="variable[input='yes']" separator=", ">
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="vtype"/><admst:text format=" %s"/>
  </admst:join>
  <admst:text format=", "/>
  <admst:join select="variable[input='yes']" separator=", ">
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="vtype"/><admst:text format=" d_%s"/>
  </admst:join>
  <admst:text format=")\n{\n"/>
  <admst:text format="  double $function=0.0;\n"/>
  <admst:for-each select="$globalanalogfunction/variable[input='yes']">
    <admst:value-of select="name"/>
    <admst:variable name="ddx" select="%s"/>
    <admst:text format="  double $(function)_$(ddx)=0.0;\n"/>
  </admst:for-each>
  <admst:for-each select="variable[input='no' and output='no']">
    <admst:text format="  "/>
    <admst:value-of select="name"/>
    <admst:variable name="name" select="%s"/>
    <admst:apply-templates select="." match="vtype"/>
    <admst:text format=" $(name)"/>
    <admst:if test="[type='integer']">=0</admst:if>
    <admst:if test="[type='real']">=0.0</admst:if>
    <admst:text format=";\n"/>
    <admst:for-each select="$globalanalogfunction/variable[input='yes']">
      <admst:text format="  "/>
      <admst:value-of select="name"/>
      <admst:variable name="ddx" select="%s"/>
      <admst:apply-templates select="." match="vtype"/>
      <admst:text format=" $(name)_$(ddx)"/>
      <admst:if test="[type='integer']">=0</admst:if>
      <admst:if test="[type='real']">=0.0</admst:if>
      <admst:text format=";\n"/>
    </admst:for-each>
  </admst:for-each>
  <admst:apply-templates select="tree" match="af:print:derivate">
    <admst:value-of select="returned('x')/value"/>
    <admst:text format="%s"/>
  </admst:apply-templates>
  <admst:text format="\n  return "/>
  <admst:join select="$globalanalogfunction/variable[input='yes']" separator="+">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:text format="$(function)_%s*d_%s"/>
  </admst:join>
  <admst:text format=";\n"/>
<admst:text format="}\n"/>
</admst:for-each>
</admst:template>


<!-- **************************************************************************
     *****                                                                *****
     *****          output instructions for QucsSim C++ file              *****
     *****                                                                *****
     ************************************************************************** -->


<!-- handling of expression -->
<admst:template match=":expression">
  <admst:value-of select="tree/adms/datatypename"/>
  <admst:apply-templates select="tree" match=":%s" required="yes"/>
</admst:template>

<admst:template match=":number">
  <admst:value-of select="value"/>
  <admst:choose>
    <admst:when test="[scalingunit='1']">%s</admst:when>
    <admst:when test="[scalingunit='E']">%sE</admst:when>
    <admst:when test="[scalingunit='P']">%sP</admst:when>
    <admst:when test="[scalingunit='T']">%sT</admst:when>
    <admst:when test="[scalingunit='G']">%sG</admst:when>
    <admst:when test="[scalingunit='M']">%sM</admst:when>
    <admst:when test="[scalingunit='k']">%sk</admst:when>
    <admst:when test="[scalingunit='h']">(%s*1e+2)</admst:when>
    <admst:when test="[scalingunit='D']">(%s*1e+1)</admst:when>
    <admst:when test="[scalingunit='d']">(%s*1e-1)</admst:when>
    <admst:when test="[scalingunit='c']">(%s*1e-2)</admst:when>
    <admst:when test="[scalingunit='m']">%sm</admst:when>
    <admst:when test="[scalingunit='u']">%su</admst:when>
    <admst:when test="[scalingunit='n']">%sn</admst:when>
    <admst:when test="[scalingunit='A']">(%s*1e-10)</admst:when>
    <admst:when test="[scalingunit='p']">%sp</admst:when>
    <admst:when test="[scalingunit='f']">%sf</admst:when>
    <admst:when test="[scalingunit='a']">%sa</admst:when>
    <admst:otherwise>
      <admst:value-of select="scalingunit"/>
      <admst:fatal format="%s%s: scaling unit not supported.\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match=":mapply_unary">
  <admst:if test="[name='plus']"> <admst:text format="+"/> </admst:if>
  <admst:if test="[name='minus']"> <admst:text format="-"/> </admst:if>
  <admst:if test="[name='not']"> <admst:text format="!"/> </admst:if>
  <admst:if test="[name='bw_not']"> <admst:text format="~"/> </admst:if>
  <admst:value-of select="arg1/adms/datatypename"/>	
  <admst:apply-templates select="arg1" match=":%s" required="yes"/>
</admst:template>

<admst:template match=":mapply_ternary">
  <admst:value-of select="arg2/adms/datatypename"/>
  <admst:apply-templates select="arg2" match=":%s" required="yes"/>
</admst:template>

<admst:template match=":string">
  <admst:value-of select="value"/>%s
</admst:template>

<admst:template match=":variable">
  <admst:value-of select="name"/>%s
</admst:template>

<admst:template match=":function">
  <admst:choose>
    <admst:when test="[name='\$simparam']"> <admst:value-of select="arguments[2]"/>%s </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:fatal format="Function '%s' not supported in parameter declaration.\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- handling of device: starting point -->
<admst:for-each select="/module">
  <!-- definition of variables -->
  <admst:value-of select="name"/>
  <admst:variable name="module" select="%s"/>
  <admst:count select="node[name!='GND']"/>
  <admst:variable name="nbr_nodes" select="%s"/>
  <admst:count select="node[location='external' and name!='GND']"/>
  <admst:variable name="nbr_extnodes" select="%s"/>
  <admst:count select="node[location='internal' and name!='GND']"/>
  <admst:variable name="nbr_intnodes" select="%s"/>
  <admst:count select="variable[input='yes']"/>
  <admst:variable name="nbr_parameters" select="%s"/>
</admst:for-each>

<admst:open file="%(filename).cpp">
<admst:for-each select="/module">
/*
 * $(module).cpp - device implementations for $(module) module
 * dynamically linked library for QucsStudio
 * created from VerilogAMS file by ADMS
 */

#include &lt;qucsstudio_library.h&gt;
#include &lt;qucsstudio_vams.h&gt;

// --------------------------------------------------------------
// component parameter definition
tParameterDef params[] = {

<admst:for-each select="variable">
  <admst:if test="[input='yes']">
    <admst:value-of select="name"/>  
    <admst:text format="  {&quot;%s&quot;, &quot;"/> 
    <admst:apply-templates select="default" match=":expression"/>
    <admst:text format="&quot;, false, &quot;"/>
    <admst:choose>
      <admst:when test="attribute[name='info']">
        <admst:value-of select="attribute[name='info']/value"/>
        <admst:text format="%s"/>
      </admst:when>
      <admst:when test="attribute[name='desc']">
        <admst:value-of select="attribute[name='desc']/value"/>
        <admst:text format="%s"/>
      </admst:when>
      <admst:when test="attribute[name='unit']">
        <admst:value-of select="attribute[name='unit']/value"/>
        <admst:text format=" (%s)"/>
      </admst:when>
      <admst:otherwise>-</admst:otherwise>
    </admst:choose>
    <admst:text format="&quot;},\n"/>
  </admst:if>
  <admst:if test="[upper-case(name)='TEMP']">
    <admst:value-of select="name"/>
    <admst:variable name="temperature_value" string="(%s+273.15)"/>
  </admst:if>
</admst:for-each>
<admst:text format="};\n"/>

<admst:text format="\n// -----------------------------------------------------\n"/>
<admst:text format="// external nodes\n"/>
<admst:for-each select="node">
  <admst:if test="[location='external' and name!='GND']">
    <admst:text format="#undef %(name)\n"/>
    <admst:text format="#define %(name)"/>
    <admst:value-of select="position(.)-2"/>
    <admst:text format=" Nodes[%s]\n"/>
  </admst:if> 
</admst:for-each>
<admst:text format="\n"/>

<admst:text format="// internal nodes\n"/>
<admst:for-each select="node"> 
  <admst:if test="[location='internal' and name!='GND']">
    <admst:text format="#undef %(name)\n"/>
    <admst:text format="#define %(name)"/>
    <admst:value-of select="position(.)-2"/>
    <admst:text format=" Nodes[%s]\n"/>
  </admst:if>
</admst:for-each>

<admst:new datatype="list" arguments="list of voltage contributions">
  <admst:variable name="vnodeList" path="."/>
</admst:new>
<admst:new datatype="list" arguments="list of noise contributions">
  <admst:variable name="noiseList" path="."/>
</admst:new>
<admst:for-each select="analog/code/item">
  <admst:apply-templates select="." match="%(datatypename):specialContrib"/>
</admst:for-each>
<admst:count select="$vnodeList/item"/>
<admst:variable name="nbr_vnodebranches" select="%s"/>
<admst:count select="$noiseList/item"/>
<admst:variable name="nbr_noisebranches" select="%s"/>

<admst:if test="[$nbr_vnodebranches!=0]">
  <admst:text format="\n// internal voltage nodes\n"/>
  <admst:for-each select="$vnodeList/item">
    <admst:text format="#undef vnode_%(pnode/name)_%(nnode/name)\n"/>
    <admst:text format="#define vnode_%(pnode/name)_%(nnode/name)"/>
    <admst:value-of select="position(.)-1"/>
    <admst:text format=" Nodes[%s+$nbr_extnodes+$nbr_intnodes]\n"/>
  </admst:for-each>
</admst:if>

<admst:if test="[$nbr_noisebranches!=0]">
  <admst:text format="\n// -----------------------------------------------------\n"/>
  <admst:text format="// global variables\n"/>
  <admst:text format="struct tGlobalVar {\n"/>
  <admst:for-each select="$noiseList/item">
    <admst:text format="  double noise%(./nature/access)_%(./branch/pnode/name)_%(./branch/nnode/name);\n"/>
  </admst:for-each>
  <admst:text format="};\n"/>
</admst:if>

<admst:text format="\n// -----------------------------------------------------\n"/>
<admst:text format="// VerilogA analog functions.\n"/>
<admst:variable name="globalanalogfunction"/>
<admst:apply-templates select="/module" match="analogfunctionC"/>
<admst:text format="\n"/>

<admst:text format="\n// -----------------------------------------------------\n"/>
<admst:text format="// Evaluate VerilogA equations in analog block.\n"/>
<admst:text format="void fillMatrix(Component *theComp, Node **Nodes, tParameter *Parameters, tGlobalVar *gVar, EqnSystem *sys, double _freq_, double _time_)\n{\n"/>

<admst:text format="  // global variables.\n"/>
<admst:for-each select="variable[scope='global_model' and input='no']">
  <admst:choose>
    <admst:when test="[sizetype='array']">
      <admst:text format="  %(vtype(.)) %(name)[%(maxsize)+1];\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  %(vtype(.)) %(name);\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:for-each select="variable[scope='global_instance' and input='no']">
  <admst:choose>
    <admst:when test="[sizetype='array']">
      <admst:text format="  %(vtype(.)) %(name)[%(maxsize)+1];\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  %(vtype(.)) %(name);\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:for-each>

<admst:text format="\n  // general variables.\n"/>
<admst:for-each select="variable[input='no' and scope='local' and sizetype='array']">
  <admst:text format="  %(vtype(.)) %(name)[%(maxsize)+1];\n"/>
</admst:for-each>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name!='initial_model' and name!='initial_instance' and name!='noise' and name!='initial_step' and name!='final_step']">
    <admst:apply-templates select="." match="block:local:declaration"/>
  </admst:if>
  <admst:if test="adms[datatypename!='block']">
    <admst:apply-templates select="." match="block:local:declaration"/>
  </admst:if>
</admst:for-each>
<admst:apply-templates select="analog/code/module/evaluation/variable" match="variable:declaration"/>
<admst:reset select="analog/code/module/evaluation/variable"/>

<admst:text format="\n  // Load device model input parameters.\n"/>
<admst:for-each select="variable">
  <admst:if test="[input='yes']">
    <admst:value-of select="position(.)-1"/>
    <admst:value-of select="name"/>
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:text format="  double %s = getNumber(Parameters[%s]);\n"/> 
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:text format="  int %s = int(getNumber(Parameters[%s]));\n"/> 
      </admst:when>
      <admst:otherwise>
        <admst:text format="  char *%s = Parameters[%s].string;\n"/> 
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:for-each>

<admst:if test="[$nbr_noisebranches!=0]">
  <admst:text format="\n  // Reset noise currents.\n"/>
  <admst:for-each select="$noiseList/item">
    <admst:text format="  gVar->noise%(./nature/access)_%(./branch/pnode/name)_%(./branch/nnode/name) = 0.0;\n"/>
  </admst:for-each>
</admst:if>

  // ----------------- evaluate verilog initial model -----------------------
<admst:text format="\n"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_model']">
    <admst:apply-templates select="." match="block:local:declaration"/>
  </admst:if>
</admst:for-each>
<admst:apply-templates select="analog/code/module/evaluation/variable" match="variable:declaration:only"/>
<admst:reset select="analog/code/module/evaluation/variable"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_model']">
    <admst:apply-templates select="." match="block"/>
  </admst:if>
</admst:for-each>

  // ----------------- evaluate verilog initial step ------------------------
<admst:text format="\n"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_step']">
    <admst:apply-templates select="." match="block:local:declaration"/>
  </admst:if>
</admst:for-each>
<admst:apply-templates select="analog/code/module/evaluation/variable" match="variable:declaration:only"/>
<admst:reset select="analog/code/module/evaluation/variable"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_step']">
    <admst:apply-templates select="." match="block"/>
  </admst:if>
</admst:for-each>

  // ----------------- evaluate verilog initial instance --------------------
<admst:text format="\n"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
    <admst:apply-templates select="." match="block:local:declaration"/>
  </admst:if>
</admst:for-each>
<admst:apply-templates select="analog/code/module/evaluation/variable" match="variable:declaration:only"/>
<admst:reset select="analog/code/module/evaluation/variable"/>
<admst:for-each select="analog/code/item">
  <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
    <admst:apply-templates select="." match="block"/>
  </admst:if>
</admst:for-each>

  // ----------------- evaluate verilog analog equations --------------------
<admst:text format="\n"/>
<admst:for-each select="analog/code/item">
  <admst:choose>
    <admst:when test="adms[datatypename!='block']">
      <admst:apply-templates select="." match="%(datatypename)"/>
    </admst:when>
    <admst:otherwise>
      <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='noise' and name!='initial_step' and name!='final_step']">
        <admst:apply-templates select="." match="block"/>
      </admst:if>
    </admst:otherwise>
  </admst:choose>
</admst:for-each>

<admst:text format="}\n\n"/>


<admst:if test="[$nbr_noisebranches!=0]">
  <admst:text format="// -----------------------------------------------------\n"/>
  <admst:text format="// Evaluate VerilogA noise equations in analog block.\n"/>
  <admst:text format="void fillNoiseMatrix(Component *theComp, Node **Nodes, tParameter *Parameters, tGlobalVar *gVar, EqnSystem *sys, double)\n{"/>
  <admst:text format="\n"/>
  <admst:for-each select="$noiseList/item">
    <admst:choose>
      <admst:when test="[nature/access='G']">
        <admst:text format="  sys->setNoiseG"/>
      </admst:when>
      <admst:when test="[nature/access='I']">
        <admst:text format="  sys->setNoiseNG"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="Wrong nature for noise branch.\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="(%(./branch/pnode/name), %(./branch/nnode/name), gVar->noise%(./nature/access)_%(./branch/pnode/name)_%(./branch/nnode/name) / BOLTZMANN);\n"/>
  </admst:for-each>
  <admst:text format="}\n"/>
</admst:if>

// --------------------------------------------------------------
// component definition
EXPORT tComponentInfo compInfo = {
  isNonLinear,                // component type ('isNonLinear' or 'isLinear')
  "$(module)",                // model identifier
  "VerilogAMS model of $(module)",  // component description
  $nbr_extnodes,                          // number of external nodes
  $nbr_intnodes+$nbr_vnodebranches,                        // number of internal nodes
  0,                          // number of inputs (system simulations only)
  $nbr_parameters,                         // number of parameters
  params,                     // pointer to list of parameters
<admst:if test="[$nbr_noisebranches!=0]">
  sizeof(tGlobalVar),         // size of global variable buffer in bytes
</admst:if>
<admst:if test="[$nbr_noisebranches=0]">
  0,                          // size of global variable buffer in bytes
</admst:if>
  0,                          // pointer to component icon (0 = unused)
  0,                          // size of component icon
  -1,                         // index of parameter determining schematic symbol (-1 = unused)
  0,                          // pointer to list of schematic symbols
  (tEvaluate)fillMatrix,      // function calculating analog model (0 = no model exists)
<admst:if test="[$nbr_noisebranches!=0]">
  (tEvaluateNoise)fillNoiseMatrix,  // function calculating noise model (0 = noise free)
</admst:if>
<admst:if test="[$nbr_noisebranches=0]">
  0,                          // function calculating noise model (0 = noise free)
</admst:if>
  0,                          // function calculating system model (0 = no model exists)
  0,                          // string with digital Verilog model (0 = no model exists)
  0                           // string with digital VHDL model (0 = no model exists)
};

<!-- ---------------------------------------------------------------------- -->

</admst:for-each>

</admst:open>

</admst>